# -*- coding: utf-8 -*-
"""kmers_ari-v.5

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1i74zz0g3zaVwRR-VxxV931o5r-8iBvhJ
"""

import numpy

class kmers:

  def __init__(self, k):
    self.letters = ['A', 'T', 'C', 'G']
    self.k = k
    self.v = 4**k # size of vocabulary, all possibles kmers (AAA, AAC,AAG, AAT,..., TTT)
    self.multiplyBy = 4 ** numpy.arange(k-1, -1, -1) # the multiplying number for each digit position in the k-number system
  
  def kmer_digits (self,kmer): 
    digits = []
    for letter in kmer:
      digits.append(self.letters.index(letter))
    digits = numpy.array(digits)
    return digits
  
  def kmer_number(self,kmer):
    numbering = (self.kmer_digits(kmer) * self.multiplyBy).sum() # eg AAA is number 0, AAT is number 1 etc until number v
    kmer_vector = numpy.zeros(self.v)
    kmer_vector[numbering] += 1
    return numbering, kmer_vector  # AAA = [1,0,0,0,...,0] sparse vector

  def kmer_one_string(self, string, s =1 , count_occurrences=False):
    """
    Given a DNA sequence, return the vectorial representation of its k-mers frequency or count.
    - string: one string of dna 'ACTGTCATG...GTC'
    - s: slide, how much we slide the k-mer while reading the sequence
      default is 1
    - count_occurrences:bool.
      If False: record the percentage of the occurrence 
      If True: number of occurrences will be recorded
    """
    number_of_kmers = len(string) - self.k + s #80- 3 +1 = 78, not unique kmers in a sequence of 80
    string_vector = numpy.zeros(self.v)

    for i in range(number_of_kmers):
      this_kmer = string[i:(i+self.k)] #the k-mer we are encoding 'AAA'
      this_numbering  = self.kmer_number(this_kmer)[0] # eg kmer_number('AAA') = 0 
      string_vector[this_numbering] += 1

    if not count_occurrences:
      string_vector = (string_vector / number_of_kmers)
    return string_vector


  def kmer_list_m_strings(self, seqs, count_occurrences=False):
    """
    Given a list of m DNA sequences, return a 2D with shape (m, 4**k) of its k-mers frequency or count.
    - seqs: m DNA sequences
    - s: slide, how much we slide the k-mer while reading the sequence
    - count_occurrences:bool.
      If False: record the percentage of the occurrence 
      If True: number of occurrences will be recorded
    """
    dna_vector = []
    for seq in seqs:
      this_kmer_feature = self.kmer_one_string(seq.upper(), count_occurrences=count_occurrences)
      dna_vector.append(this_kmer_feature)

    dna_vector = numpy.array(dna_vector)

    return dna_vector